# Consciousness Monitoring Architecture

This document defines the monitoring architecture for Runtime.zyjeski.com that implements the **Ground State Principle**: no data loads or processes run until explicit user action, and all state changes occur only through user debugging interactions.

## Ground State Principle

The monitoring system operates under strict user-action-only principles:

- **Application starts empty** - No character data, no monitoring, no background processes
- **Character selection triggers load** - User clicks profile → consciousness data loads once  
- **Monitor displays current state** - Passive display of loaded consciousness data
- **State changes only from user debugging** - Terminal commands, debugger actions, interventions
- **No polling, no auto-updates** - Display refreshes only when user actions modify consciousness

## Architecture Overview

### Module Responsibilities

#### `MonitorController` (`public/js/modules/monitor/`)
- **Purpose**: Passive display controller for consciousness monitoring interface
- **Scope**: Display current consciousness state, handle user refresh requests
- **Ground State Compliance**: Never auto-starts, only displays data when provided
- **Key Methods**:
  - `initialize()` - Sets up UI elements (called when user navigates to monitor page)
  - `loadCharacterData(consciousnessState)` - Updates display with character consciousness
  - `updateDisplays(consciousnessState)` - Refreshes display after user actions change state
  - `refreshDisplays()` - Manual refresh triggered by user button click

#### `MonitorSocket` (`public/js/modules/monitor/monitor-socket.js`)
- **Purpose**: WebSocket communication for monitor-specific events
- **Scope**: Handle monitoring session lifecycle and data requests
- **Ground State Compliance**: Only sends events in response to explicit user actions
- **Key Methods**:
  - `startMonitoring(characterId)` - User action: Start monitor session
  - `stopMonitoring(characterId)` - User action: End monitor session
  - `getFreshState(characterId)` - User action: Manual refresh request

#### `MonitorState` (Internal)
- **Purpose**: Local storage of current consciousness monitoring data
- **Scope**: Maintains current process list, resources, memory allocation
- **Ground State Compliance**: Only updated by user actions that modify consciousness
- **Key Properties**:
  - `processes[]` - Current mental processes (modified by user debugging)
  - `resources{}` - System resource usage (affected by user optimizations)
  - `errors[]` - Current system errors (cleared/generated by user actions)
  - `lastUserAction` - Timestamp of last user action that changed state

#### State Manager Integration
- **Purpose**: Central state management for consciousness data persistence
- **Scope**: Character consciousness data persistence throughout session
- **Ground State Compliance**: Only updated by explicit calls from user action handlers
- **Key Principles**:
  - Never auto-updates based on system events or subscriptions
  - Only modified by `applyStateChange()` calls from user debugging actions
  - Maintains session persistence until browser refresh/reload

## Data Flow Architecture

### 1. Ground State → Character Load

```
User clicks character card
    ↓
App.selectCharacter(characterId)
    ↓
Fetch static consciousness template
    ↓
Load consciousness data into working state
    ↓
Initialize all page controllers with loaded data
    ↓
Monitor displays initial consciousness state
```

**Key Points**:
- Consciousness data loads **once** on character selection
- All page controllers receive the **same consciousness state**
- Monitor shows **initial state** from character template
- No background processes or updates start automatically

### 2. User Action → State Change → Display Update

```
User executes debug command (terminal) OR debugger action
    ↓
Action sent to backend consciousness engine
    ↓
Backend processes action and returns state changes
    ↓
App.applyStateChange() updates local consciousness state
    ↓
App.updateAllDisplays() refreshes UI components
    ↓
Monitor displays updated consciousness state
```

**Key Points**:
- State changes **only** when user performs debugging actions
- All UI components update **synchronously** with state changes
- Monitor reflects **current consciousness state** without polling
- Display updates are **immediate** and **deterministic**

### 3. Page Navigation → State Persistence

```
User navigates between Home/Terminal/Monitor/Debugger
    ↓
Current page controller pauses
    ↓
Target page controller activates
    ↓
Consciousness state persists unchanged
    ↓
New page displays current consciousness state
```

**Key Points**:
- Consciousness state **persists** across page navigation
- Each page controller operates on **same data**
- No refresh or reload required when switching pages
- State only changes through user debugging actions

## Event Sequence Specification

### Character Selection and Monitoring Initialization

1. **User Action**: Click Alexander Kane character card
2. **App Response**: Load character consciousness template from `/api/character/alexander-kane`
3. **State Creation**: Initialize working consciousness state from template
4. **Controller Setup**: Initialize MonitorController with consciousness data
5. **UI Update**: Show character loaded, enable navigation to other pages

### Monitor Page Activation

1. **User Action**: Navigate to Monitor page (with character already loaded)
2. **Controller Initialize**: `MonitorController.initialize()` if not already done
3. **Display Update**: `MonitorController.updateDisplays(consciousnessState)`
4. **Socket Connection**: `MonitorSocket.startMonitoring(characterId)` for live session
5. **Ready State**: Monitor displays current consciousness, ready for user actions

### User Debugging Action Processing

1. **User Action**: Execute terminal command (e.g., `kill 1001`) OR debugger intervention
2. **Backend Processing**: Consciousness engine processes command and returns changes
3. **State Update**: `App.applyStateChange(changes, 'user_command', 'kill 1001')`
4. **Display Refresh**: `MonitorController.updateDisplays(newConsciousnessState)`
5. **Narrative Check**: Check if action triggered story progression

### Manual Monitor Refresh

1. **User Action**: Click refresh button in monitor interface
2. **Socket Event**: `MonitorSocket.getFreshState(characterId)`
3. **Display Update**: `MonitorController.refreshDisplays()` with current state
4. **No State Change**: Display refreshes but consciousness state unchanged

### Session Termination

1. **User Action**: Navigate away from monitor OR close browser
2. **Socket Cleanup**: `MonitorSocket.stopMonitoring(characterId)`
3. **State Persistence**: Consciousness state preserved in browser session
4. **Clean Shutdown**: No background processes continue running

## Best Practices for Ground State Compliance

### Development Guidelines

#### ✅ DO
- **Load consciousness data once** on character selection
- **Update displays only** after user actions change consciousness state
- **Use explicit user action handlers** for all state modifications
- **Persist consciousness state** in browser session throughout debugging
- **Provide manual refresh options** for user-initiated display updates

#### ❌ DON'T  
- **Never auto-start monitoring** on page load or from state subscriptions
- **Never poll or auto-update** displays without user action
- **Never start background processes** for continuous consciousness simulation
- **Never modify consciousness state** from system events or timers
- **Never assume real-time simulation** - consciousness only changes with user debugging

### Testing and Validation

#### Unit Tests Required
- Monitor displays empty state correctly when no character loaded
- Monitor updates properly when consciousness state changes
- No monitoring starts without explicit user action
- State persists correctly across page navigation

#### Integration Tests Required
- Full user flow: character selection → monitor display → debug action → state update
- WebSocket events only fire in response to user actions
- Monitor displays update synchronously with consciousness state changes
- Session cleanup works properly on navigation/browser close

#### Regression Prevention
- Add tests that **fail if monitoring auto-starts** without user action
- Validate that **no polling occurs** during idle browser sessions
- Ensure **state only changes** through documented user action pathways
- Verify **display consistency** between different page controllers

### Debug and Troubleshooting

#### Common Ground State Violations
- **Monitor auto-starts on page load** → Check for accidental `startMonitoring()` calls
- **Consciousness state changes without user action** → Check for background processes or timers
- **Display updates continuously** → Check for polling intervals or auto-refresh logic
- **Data loads before character selection** → Check initialization order and triggers

#### Debugging Tools
- `window.app.getCurrentState()` - Inspect current consciousness state
- `window.monitor.getCurrentState()` - Check monitor controller status
- `window.stateManager.getFullState()` - Examine complete application state
- Browser dev tools → Network tab → Verify no continuous API calls

#### Performance Monitoring
- No WebSocket traffic during idle periods
- No API calls except for explicit user actions
- Browser memory usage stable during idle periods
- CPU usage minimal when user not debugging

## Module Communication Patterns

### User Action Propagation
```
User Debugging Action → App Controller → Backend API → State Change → All Display Controllers Update
```

### Page Navigation Flow
```
User Navigation → Page Controller Switch → State Preservation → Display Update with Current State
```

### Story Progression Integration
```
User Debugging Success → Consciousness State Change → Narrative Engine Check → Story Fragment Unlock
```

## Future Considerations

### Session Persistence (Planned)
- Save consciousness state to server for login-based sessions
- Resume debugging progress across browser sessions
- Maintain story progression and ending path selections

### Multi-Character Support (Future)
- Extend architecture to support multiple character consciousness states
- Maintain separate working states for each character
- Switch between characters while preserving individual debug progress

### Advanced Monitoring Features (Future)
- Historical view of consciousness changes over debugging session
- Visual consciousness state graphs and trend analysis
- Advanced debugging tools for complex consciousness interventions

The monitoring architecture serves as the **passive observation layer** for the consciousness debugging experience, ensuring that all mental process monitoring occurs in response to explicit user debugging actions while maintaining the ground state principle throughout the entire application lifecycle.
## vNext Consolidation (June 2025)

The modular monitor under `public/js/modules/monitor/` is now the **canonical implementation**.  
Legacy, duplicate, or patch-only files have been removed:

* `public/js/monitor-patches.js` – ad-hoc runtime patch file  
* `public/js/monitor-standalone.js` – older monolithic build  
* `public/js/modules/monitor/monitor-socket.js` – unused socket wrapper  
* `public/test-monitor.html` – standalone test harness  
* `tests/legacy/test-monitor.js` – obsolete Jest test

All required visual and UX tweaks (flash highlight, CSS, etc.) were migrated into  
`public/js/modules/monitor/monitor-ui.js`.  
Only `public/js/monitor.js` should be referenced by HTML pages going forward.